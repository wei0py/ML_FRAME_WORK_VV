   This is a new set of code. 
   The idea is to construct a flexible framework. There will be several sets
   of functions in this framework:
   (1) Generate feature. Here, one can have different features. They can later
       be combined, and select only a subset of features. So, different feature 
       generation codes can be developed separately. 
   (2) Fitting: Here will can have different fittings: linear, linear_cluster, 
       GPR, linear_VV, Neural-Network (NN). One can also choose one from them (or
       even a few combined ones, one fitting on the residue of another one). 
   (3) MD simulation, or other after fitting operations (or active learning). 
   (4) Some test codes and sets. 

   The majority of these codes will be written in Fortran. However, they will be 
   linked together by python codes. The python code can prepare the input file 
   of these fortran codes, and different fortran code communicate through files. 

   However, the NN will be run on python based on GPU tensor flow, and the MD itself
   will also be run on python, but with Fortran code provided energy and force 
   feedback (as lib, not through file). 

  ----------------------------------------------------------------------------
  (1) In gen_feature directory, currently there are two programs:
      gen_2b_feature.f90
      gen_3b_feature.f90 

      they generate 2-body, and 3-body features respectively. One needs to have 
      input files: gen_2b_feature.in, gen_3b_feature.in to run them. In running, 
      these input files are within the "work/input" directory, while the running
      should be carried out in the work directory. The documents for these input 
      files are in the directory (DOC.genxxxx). 
   
      Note, the 2b, 3b can have different Rc (cut-off). However, they should have 
      a same Rc_M (maximum cut-off). This Rc_M, and the generated num_neighM, list_neighM, 
      are the same for all the features. It is this common neigh list which will 
      link all the feature functions together. 
      
      To run these codes, we can have multiple systems, each system should be placed 
      under one subdirectior: "work/system1, work/system2..." (any subdirectory name 
      will be fine). Within each subdirectory, one has to place the MOVEMENT file within 
      that directory. Note, within the MOVEMENT file, the number of atoms cannot be changed
      (but different MOVEMENT files under different work/systemxx can have different number 
       of atoms). 

      Before running gen_xb_feature.f90, one needs to have a location file inside work/input
      (and also on work). Currently, this location file is generate by the python code. 
      It describes the number of system, and the path to the work/systemXXX file. 

      Now, one has to prepare the gen_Xb_feature.in under work/input (later, this can be
      generated by the python code). 

      Then, in the directory of work, run gen_Xb_feature.x. It will generate dfeat.fbin.FtypeX
      info.txt.FtypeX within work/systemX. It will also generate: trainData.txt.FtypeX in the
      work directory. Note: trainData.txt.FtypeX is written using appendeding. Thus, one should not 
      run gen_Xb_feature.x multiple times. Also, trainData.txt.FtypeX is a ASCII file, containing 
      feature and energy. It can be used to do many tests based on energy only. In actually fitting, 
      trainData.txt.FtypeX is not used, and all the information are taken from dfeat.fbin.FtypeX files, 
      which has: energy, force, feature and feature_derivatives. 

      In feature, the features from different feature types (XXX.FtypeX) will be collected into full set
      of feature, before fitting. 

 (2) In fit subdirectory, we have:
     feat_collect_PCA.f
     fit_lin_forceMM.f
     calc_lin_forceMM.f

     feat_collect_PCA.f: collect all the different feature types, possibly (flag) do a PCA, and
                         stores the results in feat_new_stored0.iatype, feat_new_store.iatype. 
     It needs a feat_collect.in input file (see the DOS.feat_collect.in). It needs to be run within
     "work/input" directory. It reads the data from "work/trainData.txt.FtypeX". It will also output
     feat_PV.iatype. Depending on the flag in feat_collect.in, it will/willnot do a PCA. It also provides
     the feat_shift.iatype (containing shift and scaling information for each PCA feature). 
     It will also generate a feat.info file (for some basic feature information, num of feature etc). 
     It also provide a weight_feat.iatype (the metric weight for each feature, e.g, to be used for 
     measure the distance etc). 

     Note: feat_new_store.iatype (PCA, shift and scaled features) can be used to do many tests and preprocess
     (e.g., fitting test, LPP, classification, linear_VV etc) based on energy alone. But if actually fitting is
     done with force, the data in feat_new_store.iatype will not bs used. 

     fit_lin_forceMM.f: the linear fitting, to be run within work/input. It will use location, 
     work/systemX/dfeat.fbin.FtypeX, feat.info, feat_PV.iatype, feat_shit.iatype. It needs fit_linearMM.input 
     as the input file. It needs to provide the vdW parameter. It will carry out a linear fitting (collect all 
     the feature types). The results will be in linear_fitB.ntype. 

     calc_lin_forceMM.f: it will use linear_fitB.ntype, calculate all the force and energy, and plot that for 
     comparison with the original DFT force and energy. 
     
     


